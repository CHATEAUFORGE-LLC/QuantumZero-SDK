use anyhow::{Context, Result};
use ed25519_dalek::{Signer, SigningKey};
use serde_json::{json, Value};
use chrono::Utc;

/// Build a SCHEMA transaction (type 101) for Hyperledger Indy
pub fn build_schema_transaction(
    issuer_did: &str,
    name: &str,
    version: &str,
    attributes: &[String],
) -> Result<Value> {
    // Strip "did:sov:" prefix if present
    let did = issuer_did.strip_prefix("did:sov:").unwrap_or(issuer_did);
    
    // Generate unique request ID from timestamp
    let req_id = Utc::now().timestamp_nanos_opt()
        .ok_or_else(|| anyhow::anyhow!("Failed to generate request ID"))?;
    
    // Build transaction according to Indy schema spec
    let transaction = json!({
        "identifier": did,
        "operation": {
            "type": "101",
            "data": {
                "name": name,
                "version": version,
                "attr_names": attributes
            }
        },
        "protocolVersion": 2,
        "reqId": req_id
    });
    
    Ok(transaction)
}

/// Build a CRED_DEF transaction (type 102) for Hyperledger Indy
pub fn build_cred_def_transaction(
    issuer_did: &str,
    schema_id: &str,
    tag: &str,
    signature_type: &str,
) -> Result<Value> {
    // Strip "did:sov:" prefix if present
    let did = issuer_did.strip_prefix("did:sov:").unwrap_or(issuer_did);
    
    // Extract schema sequence number from schema_id
    // Format: <did>:2:<name>:<version> or just use the schema_id
    let ref_seq = extract_schema_seq_no(schema_id)?;
    
    // Generate unique request ID from timestamp
    let req_id = Utc::now().timestamp_nanos_opt()
        .ok_or_else(|| anyhow::anyhow!("Failed to generate request ID"))?;
    
    // Build transaction according to Indy cred def spec
    let transaction = json!({
        "identifier": did,
        "operation": {
            "type": "102",
            "ref": ref_seq,
            "signature_type": signature_type,
            "tag": tag,
            "data": {
                "primary": {
                    // Placeholder - in production, this would be generated by anoncreds
                    "n": "",
                    "s": "",
                    "r": {},
                    "rctxt": "",
                    "z": ""
                }
            }
        },
        "protocolVersion": 2,
        "reqId": req_id
    });
    
    Ok(transaction)
}

/// Sign a transaction with the issuer's private key
pub fn sign_transaction(
    transaction: &Value,
    signing_key: &SigningKey,
) -> Result<Value> {
    // Serialize transaction to canonical JSON (sorted keys, no whitespace)
    let txn_bytes = serde_json::to_vec(transaction)
        .context("Failed to serialize transaction")?;
    
    // Sign the transaction bytes
    let signature = signing_key.sign(&txn_bytes);
    
    // Encode signature as base58
    let signature_b58 = bs58::encode(signature.to_bytes()).into_string();
    
    // Add signature to transaction
    let mut signed_txn = transaction.clone();
    signed_txn["signature"] = json!(signature_b58);
    
    Ok(signed_txn)
}

/// Extract schema sequence number from schema_id
/// This is a simplified version - in production you'd query the ledger
fn extract_schema_seq_no(_schema_id: &str) -> Result<u64> {
    // For now, return a placeholder
    // In production, this would query the ledger to get the actual seq_no
    // The schema_id format is typically: <did>:2:<name>:<version>
    Ok(0)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_build_schema_transaction() {
        let txn = build_schema_transaction(
            "did:sov:H9b2WhxTmyAneTbY2uEGbG",
            "EmployeeCredential",
            "1.0",
            &["employeeId".to_string(), "fullName".to_string()]
        ).unwrap();
        
        assert_eq!(txn["identifier"], "H9b2WhxTmyAneTbY2uEGbG");
        assert_eq!(txn["operation"]["type"], "101");
        assert_eq!(txn["operation"]["data"]["name"], "EmployeeCredential");
        assert_eq!(txn["protocolVersion"], 2);
    }
    
    #[test]
    fn test_sign_transaction() {
        let txn = json!({
            "identifier": "test",
            "operation": {"type": "101"},
            "reqId": 12345
        });
        
        // Generate a test key
        let signing_key = SigningKey::from_bytes(&[0u8; 32]);
        
        let signed = sign_transaction(&txn, &signing_key).unwrap();
        assert!(signed.get("signature").is_some());
    }
}
